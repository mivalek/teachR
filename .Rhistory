"knitr::knit_hooks$set(class = function(before, options, envir){",
"  if (before){",
"    paste0('<div class=\"', options$class, '\">')",
"  } else {",
"    paste0('</div>')",
"  }",
"})",
"hook_inline = knitr::knit_hooks$get('inline')",
"knitr::knit_hooks$set(",
"  inline = function(x) {",
"    res = hook_inline(x)",
"    if (is.numeric(x)) prettyNum(format(x, scientific=FALSE), big.mark=',') else res",
"  })",
"```",
" ",
"```{r task_fun, echo=FALSE}",
"tsk <- s_tsk <- 1 # Task counter",
readLines(paste0(path.package("teachR"), "/task.txt")),
"```"
)
h <- as.vector(na.omit(h))
x <- c(h, x)
css <- "https://mivalek.github.io/sheet_files/sheets.css"
js <- "https://mivalek.github.io/sheet_files/sheets.js"
temp_rmd <- sub("\\.[Rr]md$", "_temp.Rmd", file)
writeLines(x, temp_rmd)
if (!keep_temp_Rmd) on.exit(file.remove(temp_rmd), add = T, after = F)
out_html <- sub("\\.[Rr]md$", ifelse(solution, "_sol.html", ".html"), file)
if (ntb) {
render(
input = temp_rmd,
output_format = html_notebook(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
else {
render(
input = temp_rmd,
output_format = html_document(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
file.rename(sub("\\.Rmd$", ".html", temp_rmd), out_html)
if (handout && notes) {
x <- readLines(out_html)
ind <- grep("^\\s*<h[2-9]>", x)[-1]
x[ind] <- gsub("^\\s*(<h[2-9]>.*)",
"<div class=\"noteBox\" contenteditable=\"true\"></div>\n\\1", x[ind])
writeLines(x, out_html)
}
}
#' Convert .Rmd to course-formatted HTML document or R Notebook
#'
#' Lab sheets and lecture materials should be written in R Markdown with title, subtitle, and author in YAML header. \code{make.sheets()} converts a .Rmd file into a HTML/R Notebook document applying the theme for given course.
#'
#' @param file \code{character}. Path to .Rmd file to convert.
#' @param course \code{character}. Course the sheet is for: one of \code{"dapR_1", "daprR_2", "dapR_3", "usmr", "msmr", "other"}.
#' @param solution \code{logical}. Should solutions to taks be rendered? \code{FALSE} by default.
#' @param handout \code{logical}. \code{TRUE} adds "Click for slides" link under author. To be used only for slide handout HTML files. \code{FALSE} by default.
#' @param tasks_to_headings \code{logical}. Should individual tasks and subtaks be rendered as level 2 and 3 (respectively) headings? \code{FALSE} by default.
#' @param notes \code{logical}. If \code{handout=TRUE}, then if \code{TRUE} a writable box for notes will appear at the bottom of each slide.
#' @param ntb \code{logical}. \code{TRUE} to render document as R Notebook. \code{FALSE} by default.
#' @param color \code{character}. Either a single valid colour (hex code or any of the values in \code{colours()}) or any valid value of the \code{course=} argument. If provided, it will be used to set colour scheme instead of \code{course=}.
#' @param toc \code{logical}. Should table of content be included.
#' @param toc_depth \code{logical}. Depth of headers to include in table of contents.
#' @param toc_float \code{TRUE} to float the table of contents to the left of the main document content. Rather than TRUE you may also pass a list of options that control the behavior of the floating table of contents. For more details, see \code{\link[rmarkdown]{html_document}}.
#' @param fig_width,fig_depth \code{numeric}. Default width and height (in inches) for figures.
#' @param highlight \code{character}. Syntax highlighting style. See \code{\link[rmarkdown]{html_document}}.
#' @param keep_temp_Rmd \code{logical}. Should temporary Rmd file be kept? Useful for post-hoc edits and debugging.
#' @param ... Other arguments to be passed to \code{rmarkdown:html_document} or \code{rmarkdown:html_notebook}.
#' @details Function requires a .css and .js files for correct formatting of lab sheets/handouts. These files sit on the stats website in the [root]/sheet_files folder and the path is hard-coded into the function. Look for css and js objects in function body.
#' @return \code{TRUE} if output .html file was successfully created.
#' @seealso \code{\link{handout}()}
#' @examples
#' make.sheet("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
make.sheet <- function(file, course, solution = F, handout = FALSE, tasks_to_headings = FALSE, notes = TRUE, ntb = FALSE,
color = NULL, toc = T, toc_depth = 2, toc_float = T, fig_width = 5, fig_height = 3.5,
highlight = "tango", colour = color, keep_temp_Rmd = F, ...) {
if (!file.exists(file)) stop("The file does not exist.")
if (!grepl("\\.[rR]md$", file)) stop("file= needs to be an .Rmd file.")
if (!tolower(course) %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other"))
stop("course= must be one of c(\"dapr_1\", \"dapr_2\", \"dapr_3\", \"usmr\", \"msmr\", \"and\", \"other\").")
if (course %in% c("ad", "adata")) course <- "and"
if (!is.null(colour)) color <- colour
if (!is.null(color)) {
if (length(color) != 1) stop("Please provide exactly one value to color=.")
if (color %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other")) {
course <- color
color <- NULL
} else {
if (!grepl("^#[[:xdigit:]]{3,6}$", color) && !(color %in% colours()))
stop("Invalid color provided.")
}
}
course <- gsub("r_", "R_", tolower(course))
color_list <- list(
dapR_1 = "#6bcded",
dapR_2 = "#b38ed2",
dapR_3 =  "#85a6ea",
usmr = "#eda46f",
msmr = "#d8d768",
and = "#b38ed2",
other = "#77bd9d"
)
theme_col <- ifelse(is.null(color), color_list[[course]], color)
sol <- function(x) {
if (solution) {
paste0('<div class="solBody">
<p class="solHeader>', x, '</p>')
} else paste('<br><br><br><br><br><br>
<div style="display:none;">')
}
oldwd <- getwd()
file <- gsub("\\", "/", normalizePath(file, "/", T), fixed = T)
outwd <- gsub("(.*)/.*$", "\\1", file)
file <- gsub(".*/(.*?)", "\\1", file)
setwd(outwd)
on.exit(setwd(oldwd))
x <- readLines(file)
x <- gsub("^(\\s*?)>\\s*?-", "\\1-", x) # get rid of incremental bulletpoints if used ( > - ...)
x <- gsub("#\\s*?inc\\s*?$", "", x) # get rid of #inc
yaml <- grep("---", x)
title <- grep("^\\s*?title:", x[1:yaml[2]], value = T)[1]
if (solution) title <- sub("\"$", " with solutions\"", title)
subtitle <- grep("^\\s*?subtitle:", x[1:yaml[2]], value = T)[1]
author <- grep("^\\s*?author:", x[1:yaml[2]], value = T)[1]
x <- x[-(1:yaml[2])]
x <- gsub("^\\s*(#+.*?)\\s*$", "\\1", x) # remove leading/trailing white spaces from headings
if (handout) {
x <- gsub("^#\\s*([^#])", "## \\1", x) # turn # in to ##
x[(1:length(x))[duplicated(x)]] <-
gsub("^#+.*", "", x[(1:length(x))[duplicated(x)]]) # get rid of duplicated headings
} else {
## show/hide <!-- solution or write-up
begin_comment2 <- grep("<!--", x)
end_comment <- grep("-->", x)
begin_comment <- setdiff(begin_comment2, end_comment)
end_comment <- setdiff(end_comment, begin_comment2)
if (length(begin_comment) != length(end_comment)) stop("There seems to be something wrong with the way you used '<!--' comments to designate solution body text.")
### answer formatting
ans <- grep("<!--\\s*ans", x[begin_comment])
begin_ans <- begin_comment[ans]
end_ans <- end_comment[ans]
x[begin_ans] <- "<details><summary>See answer</summary>"
x[end_ans] <- gsub("\\s*-->\\s*$", "</details>", x[end_ans])
sol <- grep("<!--\\s*solution|<!--\\s*write.?up", x[begin_comment])
begin_comment <- begin_comment[sol]
end_comment <- end_comment[sol]
for (i in seq_along(begin_comment)) {
if (solution) {
x[begin_comment[i]] <- ifelse(
grepl("<!--\\s*write.?up", x[begin_comment[i]]),
'<div class="writeUp">',
'<div class="solText">')
strip_end <- sub("\\s*-->\\s*", "", x[end_comment[i]])
x[end_comment[i]] <- "</div>"
if (strip_end != "") x[end_comment[i]] <- paste0(strip_end, "\n", x[end_comment[i]])
} else if (grepl("<!--\\s*write.?up", x[begin_comment[i]])){
height_text <- ceiling(ceiling(nchar(x[(begin_comment[i] + 1):end_comment[i]]) / 82) * 1.3)
x[begin_comment[i]] <- paste0(
'<div class="noteBox writeUp" contenteditable="true"></div>\n<!--')
}
}
}
h <- c(
"---",
title, subtitle, author,
if (handout) paste0("date: \"[Click for slides](", sub("\\.[Rr]md$", "_slides.html", file), ")\""),
"---",
" ",
"```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(theme_col), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```",
"",
"```{r, rsetup, include=F}",
"knitr::opts_chunk$set(comment=NULL, collapse=T, strip.white=F, echo=T,\n    message = F, warning = F, prompt = F, comment = NA, split = F)",
"knitr::knit_hooks$set(class = function(before, options, envir){",
"  if (before){",
"    paste0('<div class=\"', options$class, '\">')",
"  } else {",
"    paste0('</div>')",
"  }",
"})",
"hook_inline = knitr::knit_hooks$get('inline')",
"knitr::knit_hooks$set(",
"  inline = function(x) {",
"    res = hook_inline(x)",
"    if (is.numeric(x)) prettyNum(format(x, scientific=FALSE), big.mark=',') else res",
"  })",
"```",
" ",
"```{r task_fun, echo=FALSE}",
"tsk <- s_tsk <- 1 # Task counter",
readLines(paste0(path.package("teachR"), "/task.txt")),
"```"
)
h <- as.vector(na.omit(h))
x <- c(h, x)
css <- "https://mivalek.github.io/sheet_files/sheets.css"
js <- "https://mivalek.github.io/sheet_files/sheets.js"
temp_rmd <- sub("\\.[Rr]md$", "_temp.Rmd", file)
writeLines(x, temp_rmd)
if (!keep_temp_Rmd) on.exit(file.remove(temp_rmd), add = T, after = F)
out_html <- sub("\\.[Rr]md$", ifelse(solution, "_sol.html", ".html"), file)
if (ntb) {
render(
input = temp_rmd,
output_format = html_notebook(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
else {
render(
input = temp_rmd,
output_format = html_document(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
file.rename(sub("\\.Rmd$", ".html", temp_rmd), out_html)
if (handout && notes) {
x <- readLines(out_html)
ind <- grep("^\\s*<h[2-9]>", x)[-1]
x[ind] <- gsub("^\\s*(<h[2-9]>.*)",
"<div class=\"noteBox\" contenteditable=\"true\"></div>\n\\1", x[ind])
writeLines(x, out_html)
}
}
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged")
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 2)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 2)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 2)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
make.sheet("../OneDrive - University of Sussex/Pipelines/Pipelines.Rmd", "and", df_print = "paged", tasks_to_headings = T, toc_depth = 3)
.libPaths()
devtools::install_github("mivalek/teachR")
library(teachR)
getwd()
library(teachR)
?pull
??pull
library(tidyverse)
?filter
?`%<%`
?`%>%`
magrittr::`%>%`
?tibble
colortools::complementary
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::
devtools::document()
devtools::document()
devtools::document()
devtools::document
devtools::document()
#' Convert .Rmd to reveal.js slides
#'
#' Lecture slides should be written in R Markdown with title, subtitle, and author in YAML header. \code{slidify()} converts lecture .Rmd file into a reveal.js html presentation applying the theme for given course.
#'
#' @param file \code{character}. Path to .Rmd file to convert.
#' @param course \code{character}. Course the lecture is for: one of \code{"dapR_1", "daprR_2", "dapR_3", "usmr", "msmr", "other"}.
#' @param header_text \code{character}. Text to be displayed in the top right corner of slides. Course-specific text by default.
#' @param offline \code{logical}. \code{TRUE} generates reaveal.js presentation that only works locally. \code{FALSE} by default. If \code{TRUE}, \code{offline_css=} can be specified.
#' @param offline_css \code{character}. Path to .css file for offline presentations. If not specified, slides will be linked to default CSS hosted online and will require Internet connection even if hosted offline. Leave unspecified if \code{offline = FALSE}.
#' @param link_to_ho \code{logical}. \code{TRUE} (default) to display "click for handout" on title slide.
#' @param color \code{character}. Either a single valid colour (hex code or any of the values in \code{colours()}) or any valid value of the \code{course=} argument. If provided, it will be used to set colour scheme instead of \code{course=}.
#' @param incremental \code{logical}. \code{TRUE} to render slide bullets incrementally on click. \code{FALSE} by default.
#' @return Function does not return anything but outputs a .html file called [file]_slides.html and a corresponding folder with figures.
#' @param fig_width,fig_height \code{numeric}. Default width and height (in inches) for figures.
#' @param transition,background_transition \code{character}. Slide transition animation. \code{"fade"} by default. See reveal.js documentation (https://github.com/hakimel/reveal.js/blob/master/README.md) for more options.
#' @param plugins \code{character}. which plugind to include. By default \code{c("notes", "search", "chalkboard")}.
#' @param keep_temp_Rmd \code{logical}. Should temporary Rmd file be kept? Useful for post-hoc edits and debugging.
#' @details Function requires a .css and .js files for correct formatting of lab sheets/handouts. These files sit on the stats website in the [root]/slides_files folder and the path is hard-coded into the function. Look for css and js objects in function body.
#' @examples
#' slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
slidify <- function(file, course, header_text = "default", incremental = FALSE,
offline = FALSE, offline_css, link_to_ho = T,
color = NULL, fig_width = 5, fig_height = 3.5,
transition = "fade", background_transition = transition,
plugins = c("notes", "search", "chalkboard"), colour = color, keep_temp_Rmd = F) {
if (!file.exists(file)) stop("The file does not exist.")
if (!grepl("\\.[rR]md$", file)) stop("file= needs to be an .Rmd file.")
if (!tolower(course) %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other"))
stop("course= must be one of c(\"dapr_1\", \"dapr_2\", \"dapr_3\", \"usmr\", \"msmr\", \"and\", \"other\").")
if (course %in% c("ad", "adata")) course <- "and"
if (!is.null(colour)) color <- colour
if (!is.null(color)) {
if (length(color) != 1) stop("Please provide exactly one value to color=.")
if (color %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other")) {
course <- color
color <- NULL
} else {
if (!grepl("^#[[:xdigit:]]{3,6}$", color) && !(color %in% colours()))
stop("Invalid color provided.")
}
}
handout <- F # for code chunk option include=!handout
course <- gsub("r_", "R_", tolower(course))
color_list <- list(
dapR_1 = "#6bcded",
dapR_2 = "#b38ed2",
dapR_3 =  "#85a6ea",
usmr = "#eda46f",
msmr = "#d8d768",
and = "#b38ed2",
other = "#77bd9d"
)
theme_col <- ifelse(is.null(color), color_list[[course]], color)
slides_files <- "https://mivalek.github.io/slides_files"
oldwd <- getwd()
file <- gsub("\\", "/", normalizePath(file, "/", T), fixed = T)
outwd <- gsub("(.*)/.*$", "\\1", file)
file <- gsub(".*/(.*?)", "\\1", file)
setwd(outwd)
on.exit(setwd(oldwd))
x <- readLines(file)
inc_lines <- grep("#\\s*?inc\\s*?$", x) # identify lines with #inc
dist_mat <- as.matrix(dist(inc_lines)) # distances between #inc lines
distance <- dist_mat[row(dist_mat) == col(dist_mat) + 1]
gaps <- sort(c(inc_lines[c(T, distance != 1)] - 1, # where to insert empty lines
inc_lines[c(distance != 1, T)]))
y <- c(x, rep(" ", length(gaps))) # put all empty lines at the end
index <- c(seq_along(x), gaps + .5) # gaps get half-rank
x <- y[order(index)] # half-ranks get inserted in the right places
x <- gsub("^(\\s*?)(.*?)#\\s*?inc", "\\1> \\2", x) # make lines with #inc render incrementally
yaml <- grep("---", x)
title <- grep("^\\s*?title:", x[1:yaml[2]], value = T)[1]
subtitle <- grep("^\\s*?subtitle:", x[1:yaml[2]], value = T)[1]
author <- grep("^\\s*?author:", x[1:yaml[2]], value = T)[1]
x <- x[-(1:yaml[2])]
x <- gsub("^#+", "## ", x) # turn any level headings into ## headings
setup <- c(
" ",
"```{r, echo=F, include=T, eval=T, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", theme_col, ";"),
paste0("--hover-col: ", colortools::complementary(theme_col, F)[2], ";"),
"}",
"</style>",
"\")",
"```",
"",
"```{r, revealjs-setup, include=F}",
"knitr::opts_chunk$set(comment=NULL, collapse=T, strip.white=F,",
"                      warning=F, message=F,",
"                      fig.height = 3.5,",
"                      fig.width = 5)",
"def.chunk.hook  <- knitr::knit_hooks$get(\"chunk\")",
"knitr::knit_hooks$set(chunk = function(x, options) {",
"  x <- def.chunk.hook(x, options)",
"  ifelse(options$size != \"normalsize\", paste0(\"\\\\\", options$size,\"\\n\\n\", x, \"\\n\\n \\\\normalsize\"), x)",
"})",
"hook_inline = knitr::knit_hooks$get('inline')",
"knitr::knit_hooks$set(",
"  inline = function(x) {",
"    res = hook_inline(x)",
"    if (is.numeric(x)) prettyNum(format(x, scientific=FALSE), big.mark=',') else res",
"  })",
"```",
" ",
"```{r plot_theme, include=FALSE}",
"library(ggplot2)",
"bg_col <- '#fdfdfd'",
"default_col <- '#434b75'",
paste("theme_col <-", theme_col),
"complement_col <- colortools::complementary(theme_col, F)[2]",
"point_col <- paste0(default_col, '88')",
" ",
"my_theme <- cowplot::theme_cowplot() +",
"  theme(line = element_line(colour = default_col),",
"        plot.background = element_rect(fill = bg_col),",
"        panel.background = element_rect(fill = bg_col),",
"        text = element_text(colour = default_col),",
"        title = element_text(colour = default_col),",
"        axis.line = element_line(colour = default_col),",
"        axis.ticks = element_line(colour = default_col),",
"        axis.text = element_text(colour = default_col),",
"        axis.title = element_text(colour = default_col),",
"        strip.background = element_rect(fill = default_col, colour = default_col),",
"        strip.text = element_text(colour = bg_col)",
"  )",
"update_geom_defaults(\"bar\", list(fill = bg_col, colour = default_col))",
"ggplot2::theme_set(my_theme)",
"```",
" "
)
first_slide <- grep("^\\s*?##", x)[1]
x <- c(x[1:first_slide], setup, x[(first_slide + 1): length(x)])
h <- c(
"---",
title, subtitle, author,
if (!offline && link_to_ho)
paste0("date: \"[Click for handout](",
gsub("(.*)[rR]md", "./\\1html", file), ")\""),
"---")
h <- as.vector(na.omit(h))
x <- c(h, x)
temp_rmd <- gsub("\\.[Rr]md", "_temp.Rmd", file)
writeLines(x, temp_rmd)
if (!keep_temp_Rmd) on.exit(file.remove(temp_rmd), add = T, after = F)
css <- ifelse(missing(offline_css), paste0(slides_files, "/css/slides.css"), offline_css)
js <- paste0(slides_files, "/js/slides.js")
if (header_text == "default") {
header_text <-
if (grepl("dapR", course)) {
paste0(sub("_", "<strong>", course), "</strong>")
} else if (course == "usmr") {
"Univariate statistics<strong>in R</strong>"
} else if (course == "msmr") {
"Multivariate statistics<strong>in R</strong>"
} else if (course == "and") {
"Analysing<strong>data</strong>"
} else ""
}
header_file <- file.path(tempdir(), sub("\\.[Rr]md", "_header.html", file))
writeLines(
paste0("<div class=\"banner\"><div class = \"",
ifelse(course %in% c("usmr", "msmr", "and"), "header msc", "header"),
"\"><a href=\"/\">", header_text, "</a></div></div>"),
header_file)
on.exit(file.remove(header_file), add = T, after = F)
out_html <- sub("\\.[Rr]md$", "_slides.html", file)
temp_html_dir <- sub("\\.[Rr]md$", "_files", temp_rmd)
out_html_dir <- sub("_temp_", "_slides_", temp_html_dir)
render(
input = temp_rmd,
output_format = revealjs::revealjs_presentation(
fig_width = fig_width, fig_height = fig_height, self_contained = F,
transition = transition, background_transition = background_transition, incremental = incremental,
reveal_options = list(
slideNumber = "c/t", controls = F, width = 1000, height = 750, margin = 0),
reveal_plugins = plugins,
highlight = "tango", includes = includes(before_body = header_file, after_body = js),
css = css
),
intermediates_dir = tempdir(), clean = T)
file.rename(gsub("\\.[Rr]md", ".html", temp_rmd), out_html)
unlink(out_html_dir, recursive = T)
x <- readLines(out_html)
x <-  gsub(temp_html_dir, out_html_dir, x)
if (!offline) {
ind <- grep("_slides_files", x)
ind <- ind[grep("img src", x[ind], invert = T)]
x[ind] <-  gsub("^(\\s*?<link rel=\"stylesheet\" href=\").*?slides_files(.*)$",
paste0("\\1", slides_files, "\\2"), x[ind])
x[ind] <-  gsub("^(\\s*?<link href=\").*?slides_files(.*)$",
paste0("\\1", slides_files, "\\2"), x[ind])
x[ind] <-  gsub("^(\\s*?<script src=\").*?slides_files(.*)$",
paste0("\\1", slides_files, "\\2"), x[ind])
x[ind] <-  gsub("^(\\s*?\\{ src: ').*?slides_files(.*)$",
paste0("\\1", slides_files, "\\2"), x[ind])
writeLines(x, out_html)
dir.create(file.path(out_html_dir, "figure-revealjs"), recursive = T)
ff <- list.files(file.path(temp_html_dir, "figure-revealjs"), recursive = T, full.names = T)
file.copy(ff, sub(temp_html_dir, out_html_dir, ff))
files_dirs <- list.dirs(temp_html_dir, recursive = F)
for (i in grep("figure-reveal", files_dirs, invert = T, value = T)) unlink(i, recursive = T)
} else {
writeLines(x, out_html)
dirs <- list.dirs(temp_html_dir, recursive = T, full.names = F)[-1]
for (i in dirs) dir.create(file.path(out_html_dir, i), recursive = T)
ff <- list.files(temp_html_dir, recursive = T, full.names = T)
file.copy(ff, sub(temp_html_dir, out_html_dir, ff))
}
unlink(temp_html_dir, recursive = T)
}
df <- data.frame(x = LETTERS, stringsAsFactors = F)
df
class(df$x)
?grep
colortools::complementary
