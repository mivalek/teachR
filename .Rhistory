slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1", offline = T)
#' Convert .Rmd to reveal.js slides
#'
#' Lecture slides should be written in R Markdown with title, subtitle, and author in YAML header and saved on a local drive (due to Pandoc's issues with network drives). slidify() converts lecture .Rmd file into a reveal.js html presentation applying the theme for given course.
#'
#' @param file character. Path to .Rmd file to convert.
#' @param course character. Course the lecture is for: one of "dapR_1", "daprR_2", "dapR_3", "usmr", "msmr", "other".
#' @param header_text character. Text to be displayed in the top right corner of slides. Course-specific text by default.
#' @param offline logical. TRUE generates reaveal.js presentation that only works locally. FALSE by default. If TRUE, offline_css can be specified.
#' @param offline_css character. Path to .css file for offline presentations. If not specified, slides will be linked to default css hosted online and will require Internet connection even if hosted offline. Leave unspecified if offline = FALSE.
#' @param incremental logical. TRUE to render slide bullets incrementally on click. FALSE by default.
#' @return Function does not return anything but outputs a .html file called [file]_slides.html and a corresponding folder with figures.
#' @param fig_width,fig_height numeric. numeric. Default width and height (in inches) for figures.
#' @param transition,background_transition character. Slide transition animation. "fade" by default. See reveal.js documentation for more options.
#' @param plugins character. which plugind to include. By default c("notes", "search", "chalkboard").
#' @details Function requires a .css and .js files for correct formatting of lab sheets/handouts. These files sit on the stats website in the [root]/slides_files folder and the path is hard-coded into the function. Look for css and js objects in function body.
#' @examples
#' # .Rmd must be on a local drive!
#' slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
slidify <- function(file, course, header_text = "default", incremental = FALSE,
offline = FALSE, offline_css,
fig_width = 5, fig_height = 3.5,
transition = "fade", background_transition = transition,
plugins = c("notes", "search", "chalkboard")) {
if (!file.exists(file)) stop("The file does not exist.")
if (!tolower(course) %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "other"))
stop("course= must be one of c(\"dapr_1\", \"dapr_2\", \"dapr_3\", \"usmr\", \"msmr\", \"other\").")
course <- gsub("r_", "R_", tolower(course))
x <- readLines(file)
inc_lines <- grep("#\\s*?inc\\s*?$", x) # identify lines with #inc
dist_mat <- as.matrix(dist(inc_lines)) # distances between #inc lines
distance <- dist_mat[row(dist_mat) == col(dist_mat) + 1]
gaps <- sort(c(inc_lines[c(T, distance != 1)] - 1, # where to insert empty lines
inc_lines[c(distance != 1, T)]))
y <- c(x, rep(" ", length(gaps))) # put all empty lines at the end
index <- c(seq_along(x), gaps + .5) # gaps get half-rank
x <- y[order(index)] # half-ranks get inserted in the right places
x <- gsub("^(\\s*?)(.*?)#\\s*?inc", "\\1> \\2", x) # make lines with #inc render incrementally
yaml <- grep("---", x)
title <- grep("^\\s*?title:", x, value = T)
subtitle <- grep("^\\s*?subtitle:", x, value = T)
author <- grep("^\\s*?author:", x, value = T)
x <- x[-(1:yaml[2])]
x <- gsub("^#[^#]", "## ", x)
h <- c(
"---",
title, subtitle, author,
if (!offline)
paste0("date: \"[Click for handout](",
gsub("(.*)[rR]md", "./\\1html",
rev(unlist(strsplit(file, .Platform$file.sep)))[1]), ")\""),
"---",
" ",
"```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: var(--", course, "-col1);"),
paste0("--hover-col: var(--", course, "-col2);"),
"}",
"</style>",
"\")",
"```",
"",
"```{r, revealjs-setup, include=F}",
"knitr::opts_chunk$set(comment=NULL, collapse=T, strip.white=F,",
"                      fig.height = 3.5,",
"                      fig.width = 5)",
"def.chunk.hook  <- knitr::knit_hooks$get(\"chunk\")",
"knitr::knit_hooks$set(chunk = function(x, options) {",
"  x <- def.chunk.hook(x, options)",
"  ifelse(options$size != \"normalsize\", paste0(\"\\\\\", options$size,\"\\n\\n\", x, \"\\n\\n \\\\normalsize\"), x)",
"})",
"```"
)
css <- ifelse(missing(offline_css), "https://mivalek.github.io/slides_files/css/slides.css", offline_css)
js <- "https://mivalek.github.io/slides_files/js/slides.js"
if (header_text == "default") {
header_text <-
if (grepl("dapR", course)) {
paste0(sub("_", "<strong>", course), "</strong>")
} else if (course == "usmr") {
"Univariate statistics<strong>in R</strong>"
} else if (course == "msmr") {
"Multivariate statistics<strong>in R</strong>"
} else ""
}
header_file <- gsub("\\.[Rr]md", "_header.html", file)
writeLines(
paste0("<div class=\"banner\"><div class = \"",
ifelse(course %in% c("usmr", "msmr"), "header msc", "header"),
"\"><a href=\"/\">", header_text, "</a></div></div>"),
header_file)
x <- c(h, x)
out_file <- gsub("\\.[Rr]md", "_temp.Rmd", file)
writeLines(x, out_file)
pres_file <- gsub("\\.[Rr]md$", "_slides.html", file)
render(
input = out_file,
output_format = revealjs::revealjs_presentation(
fig_width = fig_width, fig_height = fig_height, self_contained = F,
transition = transition, background_transition = background_transition, incremental = incremental,
reveal_options = list(
slideNumber = "c/t", controls = F, width = 1000, height = 750, margin = 0),
reveal_plugins = plugins,
highlight = "tango", includes = includes(before_body = header_file, after_body = js),
css = css
),
output_file = pres_file)
file.remove(out_file)
file.remove(header_file)
if (!offline) {
x <- readLines(pres_file)
ind <- grep("_slides_files", x)
ind <- ind[grep("img src", x[ind], invert = T)]
x[ind] <-  gsub("^(\\s*?<link rel=\"stylesheet\" href=\").*?(slides_files.*)$", "\\1/\\2", x[ind])
x[ind] <-  gsub("^(\\s*?<link href=\").*?(slides_files.*)$", "\\1/\\2", x[ind])
x[ind] <-  gsub("^(\\s*?<script src=\").*?(slides_files.*)$", "\\1/\\2", x[ind])
x[ind] <-  gsub("^(\\s*?\\{ src: ').*?(slides_files.*)$", "\\1/\\2", x[ind])
writeLines(x, pres_file)
files_dirs <- list.dirs(sub("\\.html", "_files", pres_file), recursive = F)
for (i in grep("figure-reveal", files_dirs, invert = T, value = T)) unlink(i, recursive = T)
}
}
slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1", offline = T)
library(rmarkdown)
slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1", offline = T)
slidify("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
document()
library(roxygen2)
library(devtools)
document()
gsub("^#[^#]", "## ", "#. blah")
gsub("^#[^#.]", "## ", "#. blah")
gsub("^#[^#.]", "## ", "# blah")
gsub("^#[^#.]", "## ", "## blah")
gsub("^#[^#.]", "## ", "#.# blah")
install.packages("roxygen2")
devtools::document()
teachR::fun.index()
getwd()
devtools::document()
remotes::install_github("mivalek/teachR")
library(teachR)
?mark
getwd()
getwd()
readLines(paste0(path.package("teachR"), "/fb_gd.txt"))
readLines(paste0("inst", "/fb_gd.txt"))
c(
"\n\\ \n\n", readLines(paste0("inst", "/fb_gd.txt")), "")
teachR:::mark
file <- "../OneDrive - University of Sussex/test - Copy.Rmd"
out_file <- "../OneDrive - University of Sussex/testRmd"
ff <- readLines(file)
feedback = F; count_words = !feedback; limit = 1000; color = "#b38ed2"
# word limit reached line
insert <- '\n\\ \n\n<div><p style="color:#cc0000;font-size:2em;text-align:center">*** WORD LIMIT REACHED ***</p></div>\n\n\\ \n'
count_words && !any(grepl(insert, ff, fixed = T))
ff_edit <- ff
# name lines to identify limit-th line later
names(ff_edit) <- paste0(1:length(ff_edit), "_")
# remove code chunks
code_chunks <- matrix(grep("^\\s*```", ff_edit), ncol = 2, byrow = T)
ff_edit <- ff_edit[-unlist(apply(code_chunks, 1, function(x) x[1]:x[2]))]
# remove inserted pics
ff_edit <- grep("^!\\[", ff_edit, invert = T, value = T)
# remove inline code
ff_edit <- gsub("`.*?`", "", ff_edit)
# remove YAML header
ff_edit <- ff_edit[-c(1:grep("^\\s*---", ff_edit)[2])]
words <- unlist(strsplit(ff_edit, "\\s+"))
words <- grep("[A-Za-z]", words, value = T)
words
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
cutoff_line
cutoff_word
words[cutoff]
words[limit]
cutoff_word
1:1
ff[cutoff_line]
paste(words[grep(paste0("^", cutoff_line, "_"), names(words))])
paste(words[grep(paste0("^", cutoff_line, "_"), names(words))][1:cutoff_word], collapse = "[[:punct:]]")
ptrn <- paste(words[grep(paste0("^", cutoff_line, "_"), names(words))][1:cutoff_word], collapse = "[[:punct:]]")
ptrn
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
sub("ach course page (broken into semesters", "\\1\n", ff[cutoff_line])
sub("ach course page \(broken into semesters", "\\1\n", ff[cutoff_line])
sub("ach course page \\(broken into semesters", "\\1\n", ff[cutoff_line])
sub("(Each course page \\(broken into semesters).*", "\\1\n", ff[cutoff_line])
sub("(Each course page \\(broken into semesters)", "\\1\n", ff[cutoff_line])
??sanitize
ptrn
ptrn
words[grep(paste0("^", cutoff_line, "_"), names(words))]
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words
gsub("([\(\[\*\$])", "\\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\\1", words)
gsub("([\\(\\[\\*\\$])", "a\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\1", words)
gsub("([\\(\\[\\*\\$])", "\\\\1", words)
gsub("([\\(\\[\\*\\$\\.])", "%\\1", words)
gsub("([\\(\\[\\*\\$\\.])", "%1", words)
gsub("([\\(\\[\\*\\$\\.])", "%%1", words)
gsub("([\\(\\[\\*\\$\\.])", "\1", words)
gsub("([\\(\\[\\*\\$\\.])", "\\ \\1", words)
gsub("([\\(\\[\\*\\$\\.])", "\ \\1", words)
gsub("([\\(\\[\\*\\$\\.])", "\\\\ \\1", words)
sub(":", "", "dfsd:sdaf")
sub("^", "", "df^sd:sdaf")
sub("\\^", "", "df^sd:sdaf")
gsub("([\\(\\[\\*\\$\\.\\^])", "\\\\ \\1", words)
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\})", "\\\\ \\1", words))
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\})", "\\\\ \\1", words)
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\}])", "\\\\ \\1", words))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\}])", "\\\\ \\1", words))
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\*\\$\\.\\^])", "\\\\ \\1", words)
gsub("([\\(\\[\\*\\$\\.\\^\\#])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}\\]])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|\\]", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|\\]", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|(\\])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|(\\])", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}saf [sfds; ])")
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}saf [sfds; ])"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}sa*dsfd*^2f [sfds; ])"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
words_sane
ptrn <- paste(words_sane, collapse = "[[:punct:]]")
ptrn
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:]]")
ptrn
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:]]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
paste0("(", ptrn, ").*")
sub("Each[[:punct:]]course", "", ff[cutoff_line])
sub("Each course", "", ff[cutoff_line])
sub("Each[[:punct:]\\s]course", "", ff[cutoff_line])
sub("Each[\\s]course", "", ff[cutoff_line])
sub("Each\\scourse", "", ff[cutoff_line])
sub("Each[[:punct: ]\\s]course", "", ff[cutoff_line])
sub("Each[[:punct: ]]course", "", ff[cutoff_line])
sub("Each[[:punct:] ]course", "", ff[cutoff_line])
sub("Each[[:punct:] *]course", "", ff[cutoff_line])
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
ptrn
sub("Each[[:punct:] ]*?course", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?week,[[:punct:] ]*?with", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?week", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]", "", ff[cutoff_line])
unlist(strsplit(ff_edit, "\\s+"))
words <- unlist(strsplit(ff_edit, "\\s+"))
words
which(!is.na(as.numeric(gsub(",", "", words))))
words[which(!is.na(as.numeric(gsub(",", "", words))))]
words <- unlist(strsplit(ff_edit, "\\s+"))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
ff[cutoff_line]
length(ff)
length(unlist(strsplit(paste(ff, collapse = "\n"), "\n")))
sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
paste(ff, collapse = "\n")
strsplit(paste(ff, collapse = "\n"), "\n")
cutoff_line
ff
strsplit(paste(ff, collapse = "\n"), "\n")
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff], insert, ff[(cutoff + 1):length(ff)], feedback)
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
out_file
mark <- function(file, feedback = F, count_words = !feedback, limit = 1000, color = "#b38ed2") {
ff <- readLines(file)
out_file <- ifelse(feedback, sub("\\.Rmd$", "_marked.Rmd", file), file)
# word limit reached line
insert <- '\n\\ \n\n<div><p style="color:#cc0000;font-size:2em;text-align:center">*** WORD LIMIT REACHED ***</p></div>\n\n\\ \n'
if (count_words && !any(grepl(insert, ff, fixed = T))) {
ff_edit <- ff
# name lines to identify limit-th line later
names(ff_edit) <- paste0(1:length(ff_edit), "_")
# remove code chunks
code_chunks <- matrix(grep("^\\s*```", ff_edit), ncol = 2, byrow = T)
ff_edit <- ff_edit[-unlist(apply(code_chunks, 1, function(x) x[1]:x[2]))]
# remove inserted pics
ff_edit <- grep("^!\\[", ff_edit, invert = T, value = T)
# remove inline code
ff_edit <- gsub("`.*?`", "", ff_edit)
# remove YAML header
ff_edit <- ff_edit[-c(1:grep("^\\s*---", ff_edit)[2])]
words <- unlist(strsplit(ff_edit, "\\s+"))
numerals <- which(!is.na(as.numeric(gsub(",", "", words))))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
if (is.na(cutoff)) {
out <- c(ff, feedback)
} else {
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
}
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
} else if (feedback) {
good_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_gd.txt")),
""
)
bad_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_bd.txt")),
""
)
recom_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_rec.txt")),
""
)
# code chunk that defines --theme-col for CSS
color_chunk <-  c("```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(color), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```")
# insert chunk
ff <- c(
ff[1:grep("^\\s*---", ff)[2]],
"", color_chunk, "",
ff[(grep("^\\s*---", ff)[2] + 1):length(ff)]
)
ff[grep("<!-- THE GOOD", ff)] <- paste(good_text, collapse = "\n")
ff[grep("<!-- THE BAD", ff)] <- paste(bad_text, collapse = "\n")
ff[grep("<!-- RECOMMEND", ff)] <- paste(recom_text, collapse = "\n")
writeLines(ff, out_file)
render(input = out_file, output_format = html_document(
toc = F, includes = includes(after_body = paste0(path.package("teachR"), "/feedback.css")))
)
}
}
library(rmarkdown)
mark("../OneDrive - University of Sussex/test.Rmd", limit = 500)
as.numeric(unlist(strsplit("1_2"), "_")))
as.numeric(unlist(strsplit("1_2"), "_"))
as.numeric(unlist(strsplit("1_2", "_")))
as.numeric(unlist(strsplit(NA, "_")))
words[limit]
as.numeric(unlist(strsplit(names(words[limit]), "_")))
names(words[limit])
strsplit(names(words[limit]), "_")
message("a")
suppressWarnings
mark <- function(file, feedback = F, count_words = !feedback, limit = 1000, color = "#b38ed2") {
ff <- readLines(file)
out_file <- ifelse(feedback, sub("\\.Rmd$", "_marked.Rmd", file), file)
# word limit reached line
insert <- '\n\\ \n\n<div>
<p style="color:#cc0000;font-size:2em;text-align:center">*** WORD LIMIT REACHED ***</p>
<p style="color:#cc0000;text-align:center">(Scroll dorwn for feedback)</p>
</div>\n\n\\ \n'
if (count_words && !any(grepl(insert, ff, fixed = T))) {
ff_edit <- ff
# name lines to identify limit-th line later
names(ff_edit) <- paste0(1:length(ff_edit), "_")
# remove code chunks
code_chunks <- matrix(grep("^\\s*```", ff_edit), ncol = 2, byrow = T)
ff_edit <- ff_edit[-unlist(apply(code_chunks, 1, function(x) x[1]:x[2]))]
# remove inserted pics
ff_edit <- grep("^!\\[", ff_edit, invert = T, value = T)
# remove inline code
ff_edit <- gsub("`.*?`", "", ff_edit)
# remove YAML header
ff_edit <- ff_edit[-c(1:grep("^\\s*---", ff_edit)[2])]
words <- unlist(strsplit(ff_edit, "\\s+"))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
if (is.na(cutoff)[1]) {
out <- c(ff, feedback)
} else {
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
}
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
} else if (feedback) {
good_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_gd.txt")),
""
)
bad_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_bd.txt")),
""
)
recom_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_rec.txt")),
""
)
# code chunk that defines --theme-col for CSS
color_chunk <-  c("```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(color), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```")
# insert chunk
ff <- c(
ff[1:grep("^\\s*---", ff)[2]],
"", color_chunk, "",
ff[(grep("^\\s*---", ff)[2] + 1):length(ff)]
)
ff[grep("<!-- THE GOOD", ff)] <- paste(good_text, collapse = "\n")
ff[grep("<!-- THE BAD", ff)] <- paste(bad_text, collapse = "\n")
ff[grep("<!-- RECOMMEND", ff)] <- paste(recom_text, collapse = "\n")
writeLines(ff, out_file)
render(input = out_file, output_format = html_document(
toc = F, includes = includes(after_body = paste0(path.package("teachR"), "/feedback.css")))
)
}
}
mark("../OneDrive - University of Sussex/test.Rmd", limit = 750)
