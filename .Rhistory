gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\]\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|\\]", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|\\]", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|(\\])", "\\\\ \\1", words)
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}])|(\\])", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sadsaf [sfds; ])")
gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}saf [sfds; ])")
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}saf [sfds; ])"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", "(sad{}sa*dsfd*^2f [sfds; ])"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words"))
gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
words_sane
ptrn <- paste(words_sane, collapse = "[[:punct:]]")
ptrn
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:]]")
ptrn
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:]]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
paste0("(", ptrn, ").*")
sub("Each[[:punct:]]course", "", ff[cutoff_line])
sub("Each course", "", ff[cutoff_line])
sub("Each[[:punct:]\\s]course", "", ff[cutoff_line])
sub("Each[\\s]course", "", ff[cutoff_line])
sub("Each\\scourse", "", ff[cutoff_line])
sub("Each[[:punct: ]\\s]course", "", ff[cutoff_line])
sub("Each[[:punct: ]]course", "", ff[cutoff_line])
sub("Each[[:punct:] ]course", "", ff[cutoff_line])
sub("Each[[:punct:] *]course", "", ff[cutoff_line])
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
ptrn
sub("Each[[:punct:] ]*?course", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?week,[[:punct:] ]*?with", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?week", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?each[[:punct:] ]*?", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one[[:punct:] ]*?for[[:punct:] ]*?", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections,[[:punct:] ]*?one", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]*?sections", "", ff[cutoff_line])
sub("Each[[:punct:] ]*?course[[:punct:] ]*?page[[:punct:] ]*?\\(broken[[:punct:] ]*?into[[:punct:] ]*?semesters[[:punct:] ]*?if[[:punct:] ]*?applicable\\)[[:punct:] ]*?contains[[:punct:] ]", "", ff[cutoff_line])
unlist(strsplit(ff_edit, "\\s+"))
words <- unlist(strsplit(ff_edit, "\\s+"))
words
which(!is.na(as.numeric(gsub(",", "", words))))
words[which(!is.na(as.numeric(gsub(",", "", words))))]
words <- unlist(strsplit(ff_edit, "\\s+"))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
sub(paste0("(", ptrn, ").*"), "\\1\n", ff[cutoff_line])
sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
ff[cutoff_line]
length(ff)
length(unlist(strsplit(paste(ff, collapse = "\n"), "\n")))
sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
paste(ff, collapse = "\n")
strsplit(paste(ff, collapse = "\n"), "\n")
cutoff_line
ff
strsplit(paste(ff, collapse = "\n"), "\n")
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff], insert, ff[(cutoff + 1):length(ff)], feedback)
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
out_file
mark <- function(file, feedback = F, count_words = !feedback, limit = 1000, color = "#b38ed2") {
ff <- readLines(file)
out_file <- ifelse(feedback, sub("\\.Rmd$", "_marked.Rmd", file), file)
# word limit reached line
insert <- '\n\\ \n\n<div><p style="color:#cc0000;font-size:2em;text-align:center">*** WORD LIMIT REACHED ***</p></div>\n\n\\ \n'
if (count_words && !any(grepl(insert, ff, fixed = T))) {
ff_edit <- ff
# name lines to identify limit-th line later
names(ff_edit) <- paste0(1:length(ff_edit), "_")
# remove code chunks
code_chunks <- matrix(grep("^\\s*```", ff_edit), ncol = 2, byrow = T)
ff_edit <- ff_edit[-unlist(apply(code_chunks, 1, function(x) x[1]:x[2]))]
# remove inserted pics
ff_edit <- grep("^!\\[", ff_edit, invert = T, value = T)
# remove inline code
ff_edit <- gsub("`.*?`", "", ff_edit)
# remove YAML header
ff_edit <- ff_edit[-c(1:grep("^\\s*---", ff_edit)[2])]
words <- unlist(strsplit(ff_edit, "\\s+"))
numerals <- which(!is.na(as.numeric(gsub(",", "", words))))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
if (is.na(cutoff)) {
out <- c(ff, feedback)
} else {
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
}
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
} else if (feedback) {
good_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_gd.txt")),
""
)
bad_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_bd.txt")),
""
)
recom_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_rec.txt")),
""
)
# code chunk that defines --theme-col for CSS
color_chunk <-  c("```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(color), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```")
# insert chunk
ff <- c(
ff[1:grep("^\\s*---", ff)[2]],
"", color_chunk, "",
ff[(grep("^\\s*---", ff)[2] + 1):length(ff)]
)
ff[grep("<!-- THE GOOD", ff)] <- paste(good_text, collapse = "\n")
ff[grep("<!-- THE BAD", ff)] <- paste(bad_text, collapse = "\n")
ff[grep("<!-- RECOMMEND", ff)] <- paste(recom_text, collapse = "\n")
writeLines(ff, out_file)
render(input = out_file, output_format = html_document(
toc = F, includes = includes(after_body = paste0(path.package("teachR"), "/feedback.css")))
)
}
}
library(rmarkdown)
mark("../OneDrive - University of Sussex/test.Rmd", limit = 500)
as.numeric(unlist(strsplit("1_2"), "_")))
as.numeric(unlist(strsplit("1_2"), "_"))
as.numeric(unlist(strsplit("1_2", "_")))
as.numeric(unlist(strsplit(NA, "_")))
words[limit]
as.numeric(unlist(strsplit(names(words[limit]), "_")))
names(words[limit])
strsplit(names(words[limit]), "_")
message("a")
suppressWarnings
mark <- function(file, feedback = F, count_words = !feedback, limit = 1000, color = "#b38ed2") {
ff <- readLines(file)
out_file <- ifelse(feedback, sub("\\.Rmd$", "_marked.Rmd", file), file)
# word limit reached line
insert <- '\n\\ \n\n<div>
<p style="color:#cc0000;font-size:2em;text-align:center">*** WORD LIMIT REACHED ***</p>
<p style="color:#cc0000;text-align:center">(Scroll dorwn for feedback)</p>
</div>\n\n\\ \n'
if (count_words && !any(grepl(insert, ff, fixed = T))) {
ff_edit <- ff
# name lines to identify limit-th line later
names(ff_edit) <- paste0(1:length(ff_edit), "_")
# remove code chunks
code_chunks <- matrix(grep("^\\s*```", ff_edit), ncol = 2, byrow = T)
ff_edit <- ff_edit[-unlist(apply(code_chunks, 1, function(x) x[1]:x[2]))]
# remove inserted pics
ff_edit <- grep("^!\\[", ff_edit, invert = T, value = T)
# remove inline code
ff_edit <- gsub("`.*?`", "", ff_edit)
# remove YAML header
ff_edit <- ff_edit[-c(1:grep("^\\s*---", ff_edit)[2])]
words <- unlist(strsplit(ff_edit, "\\s+"))
words <- grep("[[:alnum:]]", words, value = T)
# identify line that includes limit-th word
cutoff <- as.numeric(unlist(strsplit(names(words[limit]), "_")))
cutoff_line <- cutoff[1]
cutoff_word <- cutoff[2]
feedback <- c('\n\n\\ \n',
'<div class="feedback">',
'<!-- THE GOOD -->',
'\n\n',
'<!-- THE BAD -->',
'\n\n',
'<!-- RECOMMENDATIONS -->',
'\n\n',
'</div>\n\n')
if (is.na(cutoff)[1]) {
out <- c(ff, feedback)
} else {
words <- words[grep(paste0("^", cutoff_line, "_"), names(words))]
words_sane <- gsub(" ", "", gsub("([\\(\\[\\{\\*\\$\\.\\^\\#\\)\\}]|\\])", "\\\\ \\1", words))
ptrn <- paste(words_sane[1:cutoff_word], collapse = "[[:punct:] ]*?")
# introduce line break after limit has been reached
ff[cutoff_line] <- sub(paste0("(", ptrn, ")"), "\\1\n", ff[cutoff_line])
# split by \n again
ff <- unlist(strsplit(paste(ff, collapse = "\n"), "\n"))
out <- c(ff[1:cutoff_line], insert, ff[(cutoff_line + 1):length(ff)], feedback)
}
writeLines(out, out_file)
render(input = out_file, output_format = html_document(toc = F))
} else if (feedback) {
good_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_gd.txt")),
""
)
bad_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_bd.txt")),
""
)
recom_text <- c(
"\n\\ \n\n",
readLines(paste0(path.package("teachR"), "/fb_rec.txt")),
""
)
# code chunk that defines --theme-col for CSS
color_chunk <-  c("```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(color), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```")
# insert chunk
ff <- c(
ff[1:grep("^\\s*---", ff)[2]],
"", color_chunk, "",
ff[(grep("^\\s*---", ff)[2] + 1):length(ff)]
)
ff[grep("<!-- THE GOOD", ff)] <- paste(good_text, collapse = "\n")
ff[grep("<!-- THE BAD", ff)] <- paste(bad_text, collapse = "\n")
ff[grep("<!-- RECOMMEND", ff)] <- paste(recom_text, collapse = "\n")
writeLines(ff, out_file)
render(input = out_file, output_format = html_document(
toc = F, includes = includes(after_body = paste0(path.package("teachR"), "/feedback.css")))
)
}
}
mark("../OneDrive - University of Sussex/test.Rmd", limit = 750)
devtools::document()
#' Convert .Rmd to course-formatted HTML document or R Notebook
#'
#' Lab sheets and lecture materials should be written in R Markdown with title, subtitle, and author in YAML header. \code{make.sheets()} converts a .Rmd file into a HTML/R Notebook document applying the theme for given course.
#'
#' @param file \code{character}. Path to .Rmd file to convert.
#' @param course \code{character}. Course the sheet is for: one of \code{"dapR_1", "daprR_2", "dapR_3", "usmr", "msmr", "other"}.
#' @param solution \code{logical}. Should solutions to taks be rendered? \code{FALSE} by default.
#' @param handout \code{logical}. \code{TRUE} adds "Click for slides" link under author. To be used only for slide handout HTML files. \code{FALSE} by default.
#' @param tasks_to_headings \code{logical}. Should individual tasks and subtaks be rendered as level 2 and 3 (respectively) headings? \code{FALSE} by default.
#' @param notes \code{logical}. If \code{handout=TRUE}, then if \code{TRUE} a writable box for notes will appear at the bottom of each slide.
#' @param ntb \code{logical}. \code{TRUE} to render document as R Notebook. \code{FALSE} by default.
#' @param color \code{character}. Either a single valid colour (hex code or any of the values in \code{colours()}) or any valid value of the \code{course=} argument. If provided, it will be used to set colour scheme instead of \code{course=}.
#' @param toc \code{logical}. Should table of content be included.
#' @param toc_depth \code{logical}. Depth of headers to include in table of contents.
#' @param toc_float \code{TRUE} to float the table of contents to the left of the main document content. Rather than TRUE you may also pass a list of options that control the behavior of the floating table of contents. For more details, see \code{\link[rmarkdown]{html_document}}.
#' @param fig_width,fig_depth \code{numeric}. Default width and height (in inches) for figures.
#' @param highlight \code{character}. Syntax highlighting style. See \code{\link[rmarkdown]{html_document}}.
#' @param keep_temp_Rmd \code{logical}. Should temporary Rmd file be kept? Useful for post-hoc edits and debugging.
#' @param ... Other arguments to be passed to \code{rmarkdown:html_document} or \code{rmarkdown:html_notebook}.
#' @details Function requires a .css and .js files for correct formatting of lab sheets/handouts. These files sit on the stats website in the [root]/sheet_files folder and the path is hard-coded into the function. Look for css and js objects in function body.
#' @return \code{TRUE} if output .html file was successfully created.
#' @seealso \code{\link{handout}()}
#' @examples
#' make.sheet("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
make.sheet <- function(file, course, solution = F, handout = FALSE, tasks_to_headings = FALSE, notes = TRUE, ntb = FALSE,
color = NULL, toc = T, toc_depth = 2, toc_float = T, fig_width = 5, fig_height = 3.5,
highlight = "tango", colour = color, keep_temp_Rmd = F, ...) {
if (!file.exists(file)) stop("The file does not exist.")
if (!grepl("\\.[rR]md$", file)) stop("file= needs to be an .Rmd file.")
if (!tolower(course) %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other"))
stop("course= must be one of c(\"dapr_1\", \"dapr_2\", \"dapr_3\", \"usmr\", \"msmr\", \"and\", \"other\").")
if (course %in% c("ad", "adata")) course <- "and"
if (!is.null(colour)) color <- colour
if (!is.null(color)) {
if (length(color) != 1) stop("Please provide exactly one value to color=.")
if (color %in% c("dapr_1", "dapr_2", "dapr_3", "usmr", "msmr", "and", "ad", "adata", "other")) {
course <- color
color <- NULL
} else {
if (!grepl("^#[[:xdigit:]]{3,6}$", color) && !(color %in% colours()))
stop("Invalid color provided.")
}
}
course <- gsub("r_", "R_", tolower(course))
color_list <- list(
dapR_1 = "#6bcded",
dapR_2 = "#b38ed2",
dapR_3 =  "#85a6ea",
usmr = "#eda46f",
msmr = "#d8d768",
and = "#b38ed2",
other = "#77bd9d"
)
theme_col <- ifelse(is.null(color), color_list[[course]], color)
sol <- function(x) {
if (solution) {
paste0('<div class="solBody">
<p class="solHeader>', x, '</p>')
} else paste('<br><br><br><br><br><br>
<div style="display:none;">')
}
oldwd <- getwd()
file <- gsub("\\", "/", normalizePath(file, "/", T), fixed = T)
outwd <- gsub("(.*)/.*$", "\\1", file)
file <- gsub(".*/(.*?)", "\\1", file)
setwd(outwd)
on.exit(setwd(oldwd))
x <- readLines(file)
x <- gsub("^(\\s*?)>\\s*?-", "\\1-", x) # get rid of incremental bulletpoints if used ( > - ...)
x <- gsub("#\\s*?inc\\s*?$", "", x) # get rid of #inc
yaml <- grep("---", x)
title <- grep("^\\s*?title:", x[1:yaml[2]], value = T)[1]
if (solution) title <- sub("\"$", " with solutions\"", title)
subtitle <- grep("^\\s*?subtitle:", x[1:yaml[2]], value = T)[1]
author <- grep("^\\s*?author:", x[1:yaml[2]], value = T)[1]
x <- x[-(1:yaml[2])]
x <- gsub("^\\s*(#+.*?)\\s*$", "\\1", x) # remove leading/trailing white spaces from headings
if (handout) {
x <- gsub("^#\\s*([^#])", "## \\1", x) # turn # in to ##
x[(1:length(x))[duplicated(x)]] <-
gsub("^#+.*", "", x[(1:length(x))[duplicated(x)]]) # get rid of duplicated headings
} else {
## show/hide <!-- solution or write-up
begin_comment2 <- grep("<!--", x)
end_comment <- grep("-->", x)
begin_comment <- setdiff(begin_comment2, end_comment)
end_comment <- setdiff(end_comment, begin_comment2)
if (length(begin_comment) != length(end_comment)) stop("There seems to be something wrong with the way you used '<!--' comments to designate solution body text.")
sol <- grep("<!--\\s*solution|<!--\\s*write.?up", x[begin_comment])
begin_comment <- begin_comment[sol]
end_comment <- end_comment[sol]
for (i in seq_along(begin_comment)) {
if (solution) {
x[begin_comment[i]] <- ifelse(
grepl("<!--\\s*write.?up", x[begin_comment[i]]),
'<div class="writeUp">',
'<div class="solText">')
strip_end <- sub("\\s*-->\\s*", "", x[end_comment[i]])
x[end_comment[i]] <- "</div>"
if (strip_end != "") x[end_comment[i]] <- paste0(strip_end, "\n", x[end_comment[i]])
} else if (grepl("<!--\\s*write.?up", x[begin_comment[i]])){
height_text <- ceiling(ceiling(nchar(x[(begin_comment[i] + 1):end_comment[i]]) / 82) * 1.3)
x[begin_comment[i]] <- paste0(
'<div class="noteBox writeUp" contenteditable="true"></div>\n<!--')
}
}
}
h <- c(
"---",
title, subtitle, author,
if (handout) paste0("date: \"[Click for slides](", sub("\\.[Rr]md$", "_slides.html", file), ")\""),
"---",
" ",
"```{r, echo=F, results='asis'}",
"cat(\"",
"<style>",
":root {",
paste0("--theme-col: ", paste(col2rgb(theme_col), collapse=", "), ";"),
"}",
"</style>",
"\")",
"```",
"",
"```{r, rsetup, include=F}",
"knitr::opts_chunk$set(comment=NULL, collapse=T, strip.white=F, echo=T,\n    message = F, warning = F, prompt = F, comment = NA, split = F)",
"knitr::knit_hooks$set(class = function(before, options, envir){",
"  if (before){",
"    paste0('<div class=\"', options$class, '\">')",
"  } else {",
"    paste0('</div>')",
"  }",
"})",
"hook_inline = knitr::knit_hooks$get('inline')",
"knitr::knit_hooks$set(",
"  inline = function(x) {",
"    res = hook_inline(x)",
"    if (is.numeric(x)) prettyNum(format(x, scientific=FALSE), big.mark=',') else res",
"  })",
"```",
" ",
"```{r task_fun, echo=FALSE}",
"tsk <- s_tsk <- 1 # Task counter",
readLines(paste0(path.package("teachR"), "/task.txt")),
"```"
)
h <- as.vector(na.omit(h))
x <- c(h, x)
css <- "https://mivalek.github.io/sheet_files/sheets.css"
js <- "https://mivalek.github.io/sheet_files/sheets.js"
temp_rmd <- sub("\\.[Rr]md$", "_temp.Rmd", file)
writeLines(x, temp_rmd)
if (!keep_temp_Rmd) on.exit(file.remove(temp_rmd), add = T, after = F)
out_html <- sub("\\.[Rr]md$", ifelse(solution, "_sol.html", ".html"), file)
if (ntb) {
render(
input = temp_rmd,
output_format = html_notebook(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
else {
render(
input = temp_rmd,
output_format = html_document(
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight,
includes = includes(after_body = c(css, js)),# md_extensions = "+fenced_code_attributes",
...
),
intermediates_dir = tempdir())
}
file.rename(sub("\\.Rmd$", ".html", temp_rmd), out_html)
if (handout && notes) {
x <- readLines(out_html)
ind <- grep("^\\s*<h[2-9]>", x)[-1]
x[ind] <- gsub("^\\s*(<h[2-9]>.*)",
"<div class=\"noteBox\" contenteditable=\"true\"></div>\n\\1", x[ind])
writeLines(x, out_html)
}
}
#' Convert .Rmd to course-formatted slide handout HTML document or R Notebook
#'
#' Lecture materials should be written in R Markdown with title, subtitle, and author in YAML header. {handout()} is a convenience function equivalent to \code{make.sheet(handout = TRUE, ...)}. It converts a .Rmd file into a HTML/R Notebook document applying the theme for given course.
#'
#' @param file \code{character}. Path to .Rmd file to convert.
#' @param course \code{character}. Course the sheet is for: one of \code{"dapR_1", "daprR_2", "dapR_3", "usmr", "msmr", "other"}.
#' @param tasks_to_headings \code{logical}. Should individual tasks and subtaks be rendered as level 2 and 3 (respectively) headings? \code{FALSE} by default.
#' @param notes \code{logical}. If \code{handout=TRUE}, then if \code{TRUE} a writable box for notes will appear at the bottom of each slide.
#' @param ntb \code{logical}. \code{TRUE} to render document as R Notebook. \code{FALSE} by default.
#' @param color \code{character}. Either a single valid colour (hex code or any of the values in \code{colours()}) or any valid value of the \code{course=} argument. If provided, it will be used to set colour scheme instead of \code{course=}.
#' @param toc \code{logical}. Should table of content be included
#' @param toc_depth \code{logical}. Depth of headers to include in table of contents.
#' @param toc_float \code{TRUE} to float the table of contents to the left of the main document content. Rather than TRUE you may also pass a list of options that control the behavior of the floating table of contents. For more details, see \code{\link[rmarkdown]{html_document}}.
#' @param fig_width,fig_depth \code{numeric}. Default width and height (in inches) for figures.
#' @param highlight \code{character}. Syntax highlighting style. See \code{\link[rmarkdown]{html_document}}.
#' @param keep_temp_Rmd \code{logical}. Should temporary Rmd file be kept? Useful for post-hoc edits and debugging.
#' @param ... Other arguments to be passed to \code{rmarkdown:html_document} or \code{rmarkdown:html_notebook}.
#' @details Function requires a .css and .js files for correct formatting of lab sheets/handouts. These files sit on the stats website in the [root]/sheet_files folder and the path is hard-coded into the function. Look for css and js objects in function body.
#' @return \code{TRUE} if output .html file was successfully created.
#' @seealso \code{\link{make.sheet}()}
#' @examples
#' handout("C:/Users/mvalasek/slides/dapR_1_handout_demo.Rmd", "dapR_1")
handout <- function(file, course, tasks_to_headings = FALSE, ntb = FALSE, color = NULL, toc = T, toc_depth = 2, toc_float = T,
fig_width = 5, fig_height = 3.5, highlight = "tango", colour = color, keep_temp_Rmd = F, ...) {
make.sheet(file = file, course = course, handout = TRUE, tasks_to_headings = tasks_to_headings, ntb = ntb, color = color,
toc = toc, toc_depth = toc_depth, toc_float = toc_float,
fig_width = fig_width, fig_height = fig_height, highlight = highlight, colour = colour, keep_temp_Rmd = keep_temp_Rmd, ...)
}
handout("../OneDrive - University of Sussex/analysing_data/lectures/lec2.Rmd", course = "and", toc_float = F)
library(teachR)
library(rmarkdown)
handout("../OneDrive - University of Sussex/analysing_data/lectures/lec2.Rmd", course = "and", toc_float = F)
handout("../OneDrive - University of Sussex/analysing_data/lectures/lec2.Rmd", course = "and", toc_float = F, keep_temp_Rmd = T)
render(
input = "../OneDrive - University of Sussex/analysing_data/lectures/lec2_temp.Rmd",
output_format = html_document(
toc = T, toc_depth = 2, toc_float = F,
includes = includes(after_body = c("https://mivalek.github.io/sheet_files/sheets.css", "https://mivalek.github.io/sheet_files/sheets.js"))
))
render(
input = "../OneDrive - University of Sussex/analysing_data/lectures/lec2_temp.Rmd",
output_format = html_document(
toc = T, toc_depth = 2, toc_float = T,
includes = includes(after_body = c("https://mivalek.github.io/sheet_files/sheets.css", "https://mivalek.github.io/sheet_files/sheets.js"))
))
devtools::document()
